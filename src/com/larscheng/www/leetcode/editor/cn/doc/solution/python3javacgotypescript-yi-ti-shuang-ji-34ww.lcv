**æ–¹æ³•ä¸€ï¼šé€’å½’**

æˆ‘ä»¬å¯ä»¥é€šè¿‡é€’å½’çš„æ–¹å¼å®ç°ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹ã€‚

é€’å½’çš„ç»ˆæ­¢æ¡ä»¶æ˜¯é“¾è¡¨ä¸­æ²¡æœ‰èŠ‚ç‚¹ï¼Œæˆ–è€…é“¾è¡¨ä¸­åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæ­¤æ—¶æ— æ³•è¿›è¡Œäº¤æ¢ï¼Œç›´æ¥è¿”å›è¯¥èŠ‚ç‚¹ã€‚

å¦åˆ™ï¼Œæˆ‘ä»¬é€’å½’äº¤æ¢é“¾è¡¨ $head.next.next$ï¼Œè®°äº¤æ¢åçš„å¤´èŠ‚ç‚¹ä¸º $t$ï¼Œç„¶åæˆ‘ä»¬è®° $head$ çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¸º $p$ï¼Œä»¤ $p$ æŒ‡å‘ $head$ï¼Œè€Œ $head$ æŒ‡å‘ $t$ï¼Œæœ€åè¿”å› $p$ã€‚

* [sol1-Python3]

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head is None or head.next is None:
            return head
        t = self.swapPairs(head.next.next)
        p = head.next
        p.next = head
        head.next = t
        return p
```

* [sol1-Java]

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode t = swapPairs(head.next.next);
        ListNode p = head.next;
        p.next = head;
        head.next = t;
        return p;
    }
}
```

* [sol1-C++]

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if (!head || !head->next) {
            return head;
        }
        ListNode* t = swapPairs(head->next->next);
        ListNode* p = head->next;
        p->next = head;
        head->next = t;
        return p;
    }
};
```

* [sol1-Go]

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func swapPairs(head *ListNode) *ListNode {
	if head == nil || head.Next == nil {
		return head
	}
	t := swapPairs(head.Next.Next)
	p := head.Next
	p.Next = head
	head.Next = t
	return p
}
```

* [sol1-TypeScript]

```ts
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function swapPairs(head: ListNode | null): ListNode | null {
    if (!head || !head.next) {
        return head;
    }
    const t = swapPairs(head.next.next);
    const p = head.next;
    p.next = head;
    head.next = t;
    return p;
}
```

æ—¶é—´å¤æ‚åº¦ $O(n)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(n)$ï¼Œå…¶ä¸­ $n$ æ˜¯é“¾è¡¨çš„é•¿åº¦ã€‚

---

**æ–¹æ³•äºŒï¼šè¿­ä»£**

æˆ‘ä»¬è®¾ç½®ä¸€ä¸ªè™šæ‹Ÿå¤´èŠ‚ç‚¹ $dummy$ï¼Œåˆå§‹æ—¶æŒ‡å‘ $head$ï¼Œç„¶åè®¾ç½®ä¸¤ä¸ªæŒ‡é’ˆ $pre$ å’Œ $cur$ï¼Œåˆå§‹æ—¶ $pre$ æŒ‡å‘ $dummy$ï¼Œè€Œ $cur$ æŒ‡å‘ $head$ã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éå†é“¾è¡¨ï¼Œæ¯æ¬¡éœ€è¦äº¤æ¢ $pre$ åé¢çš„ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œå› æ­¤æˆ‘ä»¬å…ˆåˆ¤æ–­ $cur$ å’Œ $cur.next$ æ˜¯å¦ä¸ºç©ºï¼Œè‹¥ä¸ä¸ºç©ºï¼Œåˆ™è¿›è¡Œäº¤æ¢ï¼Œå¦åˆ™ç»ˆæ­¢å¾ªç¯ã€‚

* [sol2-Python3]

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(next=head)
        pre, cur = dummy, head
        while cur and cur.next:
            t = cur.next
            cur.next = t.next
            t.next = cur
            pre.next = t
            pre, cur = cur, cur.next
        return dummy.next

```

* [sol2-Java]

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0, head);
        ListNode pre = dummy;
        ListNode cur = head;
        while (cur != null && cur.next != null) {
            ListNode t = cur.next;
            cur.next = t.next;
            t.next = cur;
            pre.next = t;
            pre = cur;
            cur = cur.next;
        }
        return dummy.next;
    }
}
```

* [sol2-C++]

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummy = new ListNode(0, head);
        ListNode* pre = dummy;
        ListNode* cur = head;
        while (cur && cur->next) {
            ListNode* t = cur->next;
            cur->next = t->next;
            t->next = cur;
            pre->next = t;
            pre = cur;
            cur = cur->next;
        }
        return dummy->next;
    }
};
```

* [sol2-Go]

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func swapPairs(head *ListNode) *ListNode {
	dummy := &ListNode{Next: head}
	pre, cur := dummy, head
	for cur != nil && cur.Next != nil {
		t := cur.Next
		cur.Next = t.Next
		t.Next = cur
		pre.Next = t
		pre, cur = cur, cur.Next
	}
	return dummy.Next
}
```

* [sol2-TypeScript]

```ts
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function swapPairs(head: ListNode | null): ListNode | null {
    const dummy = new ListNode(0, head);
    let [pre, cur] = [dummy, head];
    while (cur && cur.next) {
        const t = cur.next;
        cur.next = t.next;
        t.next = cur;
        pre.next = t;
        [pre, cur] = [cur, cur.next];
    }
    return dummy.next;
}
```

æ—¶é—´å¤æ‚åº¦ $O(n)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(1)$ï¼Œå…¶ä¸­ $n$ æ˜¯é“¾è¡¨çš„é•¿åº¦ã€‚

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~
