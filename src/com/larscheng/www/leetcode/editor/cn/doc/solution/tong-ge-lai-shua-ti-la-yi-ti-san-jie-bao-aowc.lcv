# 方法一、暴力

题目约定了数组的长度最大只有 100，所以，这道题我们使用暴力求解也就可以的。

暴力的方法就是从下标 0 开始，依次计算其开头的1、3、5...奇数长度的子数组之和。

请看代码：

* java

```java
class Solution {
    public int sumOddLengthSubarrays(int[] arr) {
        int ans = 0;
        // 从 0 开始遍历1、3、5..奇数长度的子数组
        for (int i = 0; i < arr.length; i++) {
            for (int j = 1; j <= arr.length; j += 2) {
                // 判断不越界
                if (i + j - 1 < arr.length) {
                    for (int k = 0; k < j; k++) {
                        ans += arr[i + k];
                    }
                }
            }
        }
        return ans;
    }
}
```

- 时间复杂度：$O(n^3)$，针对每一个下标每一个奇数长度都要算一遍。
- 空间复杂度：$O(1)$，只有少数变量占用常量空间。

运行结果如下：

![image-20210829101306526](https://pic.leetcode-cn.com/1630224906-EkULOL-file_1630224905942)

# 方法二、前缀和

方法一中，我们可以看到每次都要计算 `i` 到 `i + j - 1` 之间的连续和，其实有大量的重复计算，这里可以利用昨天的每日一题中用到的方法——前缀和——来优化。

利用前缀和，我们可以快速的计算出两个下标之间的所有元素的和。

比如，以 `arr = [1,4,2,5,3]`为例，它的前缀和为：`preSum = [1,5,7,12,15] `，当我们需要计算下标 1 和下标 3 之间所有元素的和直接使用 `preSum[3] - preSum[1 - 0] = 11` 即可。

请看代码：

* java

```java
class Solution {
    public int sumOddLengthSubarrays(int[] arr) {
        int ans = 0;
        // 先计算前缀和
        int[] preSum = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            preSum[i] = arr[i] + (i - 1 < 0 ? 0 : preSum[i - 1]);
        }

        // 从 0 开始遍历1、3、5..奇数长度的子数组
        for (int i = 0; i < arr.length; i++) {
            for (int j = 1; j <= arr.length; j += 2) {
                // 判断不越界
                if (i + j - 1 < arr.length) {
                    ans += preSum[i + j - 1] - (i - 1 < 0 ? 0 : preSum[i - 1]);
                }
            }
        }
        return ans;
    }
}
```

- 时间复杂度：$O(n^2)$，计算前缀和的时间复杂度为 $O(n)$，计算每个奇数子数组的和的时间复杂度为 $O(n^2)$，所以，总的时间复杂度为 $O(n^2)$。
- 空间复杂度：$O(n)$，前缀和需要占用 $O(n)$ 的空间，可以看到，在题目的后续也没有用到 arr 数组了，所以，也可以原地修改 arr 数组表示为前缀和，可以将空间复杂度降低到 $O(1)$。

运行结果如下，鉴于用例范围比较小，所以，效果不明显：

![image-20210829102517108](https://pic.leetcode-cn.com/1630224906-avhdmA-file_1630224906054)

# 方法三、数学

题目要求的是奇数长度的子数组，那么，我们可以不失一般性地考虑，原数组中的每个数一共会出现在多少个奇数子数组中，也就是这个数一共会出现多少次，这样的话，我们把所有元素遍历一遍，找到每个数出现的次数，相乘再相加就得到结果了。

比如，以 `arr = [1,4,2,5,3]`为例，假设我们现在要看 **2** 这个元素在哪些子数组中会出现，我们可以先试着画出下面这张图：

![image-20210829154918199](https://pic.leetcode-cn.com/1630224906-EQwqsA-file_1630224905967)

明显地，在包含 2 的所有子数组中，从 2 的位置分成两半，它左边的部分和它右边的部分必须同时为偶数或者奇数，才能组成奇数长度的子数组。

这也很好理解，相当于从一个奇数子数组中去掉 2 这个数，那剩下的数肯定是偶数，而这些数不是在 2 的右边，就是在 2 的左边，一个偶数分两半，那肯定是同偶或者同奇的。

OK，这样的话，我们只要算出一个数 左边可能为奇数的数量 与 右边可能为奇数的数量、左边可能为偶数的数量与右边可能为偶数的数量，两两相乘再相加就是这个数可能出现的所有奇数子数组的数量，再乘以这个数本身，就是这个数对结果的贡献。

比如，还是上面的例子，2 的左边可能为奇数的数量只有 1个，同样地，右边也是 1，`1 * 1 = 1`，所以 2 两边同奇的可能性只有 1；2的左边可能为偶数的数量为 0 或 2 两种可能，右边也是 0 或 2 两种可能，`2 * 2 = 4`，所以，2 的两边同偶的可能性有 4 种。奇偶两种情况一共是 5 种，再乘以 2 本身等于 10，就是对结果的贡献。

好了，请看代码：

* java

```java
class Solution {
    public int sumOddLengthSubarrays(int[] arr) {
        int ans = 0;

        int n = arr.length;
        // 1,4,2,5,3
        // 0,1,2,3,4
        for (int i = 0; i < n; i++) {
            // 左边奇数个数的可能性
            int leftOddCount = (i + 1) / 2;
            // 右边奇数个数的可能性
            int rightOddCount = (n - i) / 2;
            // 左边偶数个数的可能性
            int leftEvenCount = i / 2 + 1;
            // 右边偶数个数的可能性
            int rightEvenCount = (n - i - 1) / 2 + 1;
            // 计算结果
            ans += arr[i] * (leftOddCount * rightOddCount + leftEvenCount * rightEvenCount);
        }
        
        return ans;
    }
}
```

- 时间复杂度：$O(n)$，遍历一遍即可。
- 空间复杂度：$O(1)$，只需要常数数量的变量。

运行结果如下：

![image-20210829161311635](https://pic.leetcode-cn.com/1630224967-DHyzoJ-file_1630224967780)

# 最后

**如果对你有帮助，请点个赞吧，谢谢^^**

也可以关注我的公号【彤哥来刷题啦】，每日分享题解，一起刷题，一起拿全家桶。
