### 解题思路

可以分别考虑答案的每一位，下面以第0位为例分析
我们知道，nums算上空集，一共有2^n个子集异或结果
首先需要证明：对于任意一位，2^n个子集异或结果中
1. 如果nums中任何一个数字在这一位上都是0，则任何一个子集的异或结果在这一位上都是0
2. 如果nums中有一个数字在这一位上是1，则所有子集异或结果中在这一位上，一半是0，一半是1

结论1显而易见，我就不赘述了

下面用数学归纳法进行证明结论2(为表述方便，下面设nums的下标从1开始)：
当n = 1时，数组的子集就是{} {nums[1]}，空集看成0，当nums[1]的某一位为1时，则这一位上为1的子集个数为1(就是其自身)，这一位上为0的子集个数为1（就是空集），满足结论2。

假设当n = k - 1时，结论2成立
则当n = k时，有两种子集
子集1: 2^(k - 1)个子集是n = k - 1时的子集
子集2: 另外2^(k - 1)个子集是n = k - 1时的子集与nums[k]异或得到

由n = k - 1时的结论可知，2^(k - 1)个子集在任意一位上，一半是0，一半是1

第一种情况nums[k]在任意位上是0，则子集1不变，依旧一半是0，一半是1，子集2里也是一半是0，一半是1
第二种情况nums[k]在任意位上是1，则子集1不变，依旧一半是0，一半是1，子集2里将原来为0的变成了1，原来为1的变成了0，所以依然是一半是0，一半是1

所以n = k时，结论成立

由第一数学归纳法可知，结论成立。

有了这个结论之后，我们可以得知，如果nums中有一个数字在这一位上是1，则有一半(2^(n-1))子集在这一位上是1，所以我们先对nums中所有数字求或，再乘以2^(n - 1)便得到最终答案

### 代码

* java

```java
class Solution {
    public int subsetXORSum(int[] nums) {
        int res = 0;
        for (int num : nums) {
            res |= num;
        }
        return res << (nums.length - 1);
    }
}
```

