> Problem: [32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/description/)

[TOC]

# 前言

既然人生那么短暂，那就不要犹豫，不妨大胆地去追逐你喜欢的东西吧。

“庄生晓梦迷蝴蝶，望帝春心托杜鹃。”
愈是破晓时分的梦，愈想痴迷那翩翩起舞的蝴蝶；
哪怕燃尽我一切的热情，我也要托我耳目所及的一切、将我的心意传递给你。

当然也可能有遗憾，没关系的，
很多时候，正是留着遗憾，才让人懂得珍惜。

> 人生好景万千，目光不止停留于眼前。
> 透过这道简单题，似乎能看见人世间的万语千言。

# 思路

> 以下小标题来自**屈原《离骚》**，看不懂没关系，意识流是这样的。

我的**意中人**，是一个**绝代佳人**。
她平日离我很**远**，却总在我内心孤独的时候离我很**近**。
印象中，她面向**夕阳**，独立，而我站在她的**背影**里。
你知道的，我在**等待**她回头。

## ①朝吾将济于白水兮

> **等待**

一遍一遍在纸上工整地写着她的**名字**，
把对她的一切**期待**凝结在笔尖。
笔尖在纸上**走路**，我在宠溺的眼光中**走神**。
我在等你啊、等待你也把目光投向我。

> '**(**'即等待。我们把'**(**'的下标入栈，这样每次取出的'**(**'一定离待匹配'**)**'最近。

## ②登阆风而绁马

> 途中的**收获**

我看见你**回头**将目光洒向我，满心**欢喜**。
看来**等待**没有白费。

> **回头**，即遇见'**)**'。
> **欢喜**，即更新**ans = max { i - j , ans }**。
> **i** 是当前遍历到的下标，**j** 是除本次'**(**'之前的一次'**(**'的下标，即取出栈顶元后的**下一个**栈顶元。
> **i - j** 即为当前子串长度。

## ③忽反顾以流涕兮

> 崩溃之前，**回光返照的爱意**终于到达**顶峰**

终于，你愿意**转身**，伸出双臂，与我相拥。
我好**开心**，似乎过往一切的**等待**都在此刻赋予了**意义**。
可是，为什么我内心却感到一丝**空虚**呢……

> **转身**，即所有'**(**'和'**)**'均已配对，当前子串达到最长。
> 赋予**意义**，即更新**ans = max { i - start , ans }**。
> **i** 是当前遍历到的下标，**start** 是子串开始的**前一个**位置。

## ④哀高丘之无女

> **“是的，我曾一直喜欢着你……只可惜，似乎、已经回不去了。”**

我的**心**哭了。
真的、谢谢你，谢谢你的**感情**。
明明我应该对你的**青睐**欣喜若狂的，
——可是，我发现：
你已经**不是**我**记忆里的你**了……

抱歉啊，我、必须、**斩断**过往的那些**执念**了。

> 当多出一个'**)**'时(栈空)，前面没有剩余的‘**(**’与之匹配。
> 于是前面的子串不再可能再与后面拼接成更大的子串。
> 于是**斩断**，更新 **start = i** 截断前面的子串，后续的子串最长从**start**开始。

。。。。。。**谢谢你**。

# 解题方法

![fe9cdc1079c36c8516f69d26a350224.jpg](https://pic.leetcode.cn/1703414556-CRPpJp-fe9cdc1079c36c8516f69d26a350224.jpg)

> 具体条件判断参看注释，应该写的很详细了。

# 复杂度

时间复杂度:

> $Θ(n)$        //遍历一遍的水平

空间复杂度:

> $O(n)$        //最多全入栈

# Code

* []

```C++
class Solution {
public:
    int longestValidParentheses(string s) {
        int num = s.size();
        int ans = 0;
        int start = -1;
        vector<int> stack;      //存放‘(’的下标
        for( int i = 0 ; i < num ; i ++ ){
            if( s[i] == '(' ){  //遇到'('
                stack.push_back(i);     //下标入栈
            }
            else{               //遇到')'
                if( stack.empty() ){
                    //栈空，此时因为s[i]是‘)’，且前面没有剩余的‘(’与之匹配
                    //于是前面的子串不再可能再与后面拼接成更大的子串
                    //我们直接更新 start = i 截断前面的子串，后续的子串最长从start开始
                    start = i;
                }
                else{
                    //栈不空，即有‘(’与之匹配，先将其出栈
                    stack.pop_back();
                    //此时需要考虑该处已经匹配的括号前面是否还有‘(’未匹配
                    if( stack.empty() ){
                        //栈空，说明从start之后(不包括start)的括号均已配对
                        //取当前子串长度 i - start 和已有ans比较，取最大值
                        ans = max( i - start , ans );
                    }
                    else{
                        //栈不空，说明从start之后还有‘(’等待配对
                        //此时栈顶的‘(’即为最近的未匹配括号，下标记为j
                        //则从 j + 1 开始取得当前最长子串长度 i - j，
                        //并和已有ans比较，取最大值
                        ans = max( i - stack.back() , ans );
                    }
                }
            }
        }

        return ans;
    }
};
```

