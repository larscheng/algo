# 一、暴力法

暴力法，虽然0ms，超过100%，但我相信O(n)肯定不是最优解的

* java

```java
public int xorOperation(int n, int start) {
    int r = start;
    while (--n > 0) r ^= start += 2;
    return r;
}
```

时间复杂度O(N)，空间复杂度O(1)。

# 二、O(1)位运算法

不过我相信这道题应该有O(1)时间解法的。

当然我自己最后还是没有想出来，但是看了其他题解，稍微有一些理解了。

## 1. 思路

因为在运算过程中，最后一位对于前面的计算是没有影响的，所以可以先将所有数整体右移一位（最后一位单独计算），先计算前面k-1位的（假设结果共有k位）：

如原数列为1->3->5->7->9...
即0001->0011->0101->0111->1001->...

右移一位变为000->001->010->011->100->...
即0->1->2->3->4->...

即现`nums[i]`由`start+2i`变为了`start/2 + i`，记`t = start/2`，则新的`nums[i]`为`t + i`。

## 2. 异或的性质

异或有性质

> a. 2x ⊕ (2x+1) = 1
> b. 2x ⊕ 1 = 2x+1
> c. x ⊕ x = 0
> d. x ⊕ 0 = x

## 3. 计算前k-1位

记$f(n) = t ⊕ (t+1) ⊕ ... ⊕ (t+n-1)$，`f(n)`即为最终结果的前k-1位。

当t为偶数时，有：

> n=1，f(n) = t
> n=2，f(n) = t ^ (t+1) = 1，由性质a
> n=3，f(n) = 1 ⊕ t+2 = t+3，由性质b
> n=4，f(n) = t+3 ⊕ t+3 = 0，由性质c
> n=5，f(n) = 0 ⊕ t+4 = t+4，由性质d
> ……

可发现f(n)的值按4循环。规律如下：
**若n = 4i+1，f(n) = t + n - 1**
**若n = 4i+2，f(n) = 1**
**若n = 4i+3，f(n) = t + n**
**若n = 4i，f(n) = 0**

当t为奇数时，那么就从t+1开始计算，最后再与t进行异或即可。

**到此为止，除了最后一位其他位数都可以算出来了。**

## 4. 计算最后一位

最后还剩一个问题，即最后一位的计算。
简单推理可以得到：
1. 如果start为偶数的话，那么最后一位无论如何都是0；
2. 如果start为奇数的话，那么最后一位则是1->0->1->0依次循环。

以上统一表达的话，可以表示为`start & n & 1`。

最终，将前k-1位与最后一位合并起来，即是结果。

## 5. 代码

附详细注释的代码：

* java

```java
public int xorOperation(int n, int start) {
    int last = start & n & 1;
    int t = start >> 1; // 右移一位
    int newT = (t & 1) == 1 ? t + 1 : t; // 如果t为奇数，从t+1开始计算
    int newN = (t & 1) == 1 ? n - 1 : n; // 如果t为奇数，从t+1开始计算
    int mod = newN & 3; // n除以4的余数
    /*
     * 若n = 4i+1，f(n) = t + n - 1
     * 若n = 4i+2，f(n) = 1
     * 若n = 4i+3，f(n) = t + n
     * 若n = 4i，f(n) = 0
     */
    int fn = switch (mod) {
        case 1 -> newT + newN - 1;
        case 2 -> 1;
        case 3 -> newT + newN;
        default -> 0;
    };
    if (t != newT) fn ^= t; // 如果t为奇数，最后还要与t异或
    return (fn << 1) | last; // 左移一位，并加上最后一位
}
```

时间复杂度O(1)，空间复杂度O(1)。
